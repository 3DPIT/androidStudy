# 쓰레드를 생성하는 더 좋은 방법![image-20200617175024478](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617175024478.png)

#### 쓰레드 풀

```
미리 쓰레드를 생성해서 저장함 

그리고 처리해야할 작업이 등장하면 Runnable 인터페이스를 구현하는 인스턴스를
생성하는 다음에 쓰레드 생성 요청을 했었는데 
그냥 작업을 밀어 넣으면 

쓰레드 풀에서 쓰레드 햔개를 할당 해준다 
그작업을 처리하고 원래는 이전에는 그 쓰레드는 소멸을 했엇는데 
여기서는 작업을 마치게 되면 다시 쓰레드 풀로 돌아간다. 
그리고 다음 작업이 할당 되기를 기다린다. 
```

양이 많지는 않지만 구현자체가 어려웠다. 



````
처리해야하는 양들이 있을때 몇개의 쓰레드를 생성해야하는지
우리가 그냥 필요할때 마다 생성해서 소멸하면 되지 않은가 생각 할 수있는데
그렇게 드는 생성과 소멸하는 시간이 아깝다 

그래서 미리 만들어놓고 필요할때 쓰고 넣고 하자 하는 개념이다. 

13개의 작업이 있을때 원래 13개 생성 소멸을 해야하는데

쓰레드 풀은 그 시간을 줄여준다. 
````

게임 서버도 사실 한개의 쓰레드로 구현을 하긴한다. 

16개의 코어에 맞는 쓰레드 갯수를 실습을 통해 최적을 찾는다. 



### 쓰레드 풀 코드

![image-20200617175726188](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617175726188.png)



newSingleThreadExecutor()로 쓰레드풀이 가능하다. 

submit();으로 처리를 해준다. 

shutdown(); 매소드는 쓰레드를 정말 소멸하기 위한 메소드 

![image-20200617175937568](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617175937568.png)

newFixedThreadPool (3) 이렇게 하면 쓰레드 풀안에 3개의 쓰레드 생성해서 유지 



newCachedThreadPool 작업의 수에 맞게 유동적 관리하는것인데

고객마다 다르고, 하기 때문에 어느정도까지 유동적 관리하는지는 모른다.

![image-20200617181011003](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617181011003.png)



![image-20200617181138008](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617181138008.png)

```
메인문에서 
1~100까지 더하려고 하는데 그렇지 않고 
t1 쓰레드 너는 1-50 까지 더하고
t2 쓰레드 너는 51-100까지 더하라고 할 수있다.

하지만 main이 취합을 해야하는데 
때에 따라 쓰레드도 연산 결과를 반환을 해야하는 경우가 있다는 것이다. 

지금까지 했던 run 메소드는 반환형이 void 였다 그래서 값을 반환 할 수 없었는데
값을 반환하기 위해서는 
Callable 인터페이스를 구현하면된다 가장큰 차이는 반환형이 있고 없고의 차이와
Callable 인터페이스로 구현하는 것은  우리가 반환형을 선택 할 수 있다. 
```



![image-20200617181447659](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617181447659.png)

작업을 제출하고 반환형을 받아야한다. 

get()메소드가 실행된다고 바로 값이 반환되는것은 아니고 끝날때 까지 기다린다.





### 동기화의 다른 방법

![image-20200617181623739](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617181623739.png)

```
여기서 보면 lock();과
          unlock(); 으로 감싸져있는 부분은 한쓰레드에서만 동작하는 부분이다.
```

자물쇠는 여러개 만들어서 사용이 가능하다. 

 ### 권고하는 코드 스타일

```
lock();
try{

}finally{
		unlock();
}
이런식으로 해라를 권장한다.
```





## 컬렌션 인스턴스 동기화



![image-20200617181957187](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617181957187.png)

둘이상의 쓰레드 접근하지 못하게 하는게 동기화 

![image-20200617182050823](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617182050823.png)

```
lst라는 참조변수로 지금 참조하고 잇는데 
lst라는 애를 통한 접근이 동기화가 되어있는 것이다.

현재는 접근하는 방식에만 동기화가 되어있는 것이다. 

Runnale 메소드를 보면 반복자를 통해 구현이 되어있다. 하지만 잘 생각해보면
반복자 자체도 하나의 인스턴스 였다.

반복자를통한 접근시 그것도 동기화가 되냐 하는 문제 인데 그경우는 되지 않는다.

그래서 반복자 자체도 동기화를 해야하는것이다. 

```

![image-20200617182550169](%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC%20%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%20%EB%8D%94%20%EC%A2%8B%EC%9D%80%20%EB%B0%A9%EB%B2%95.assets/image-20200617182550169.png)

이렇게 해서 반복자를 통해 얻어서 쓰는 곳에서도 동기화를 해줘야합니다. 

좀더 세밀한 동기화를 위해 반복자 자체에도 동기화를 해줘야한다고 자바에서 

명시하고 있다. 그래서 그런 법칙을 따르는게 좋다.



```
awaitTermination(100, TimeUnit.SECONDS);
여기메소드는 
최대 100초를  메소드 작업끝나는 시간을  기다리겠다는 것이다.
```


# 쓰레드 동기화

#### 동기화가 왜 필요한지

쓰레드의 문제가 무엇일까?

![image-20200617164941374](34-2%20%EC%93%B0%EB%A0%88%EB%93%9C%20%EB%8F%99%EA%B8%B0%ED%99%94.assets/image-20200617164941374.png)

join t1 ,t2의 흐름이 종료 될떄 까지 기다리겠다 하는것 

원래 결과적으로 cnt 값은  0 이되어야 한다. 



하지만 실행 할때마다 값이 달라진다. 

이런 문제가 생기는 이유가 무엇일까???

![image-20200617165228408](34-2%20%EC%93%B0%EB%A0%88%EB%93%9C%20%EB%8F%99%EA%B8%B0%ED%99%94.assets/image-20200617165228408.png)

```
코어가 한개라고 과정하고 
시간을 작게 쪼개서 나누는데 
t1
int num = 1+2;

t2
int num = 2+3;

라고 하면 저게 한개씩 끝나고 넘어간다고 생각하지만 하다가 넘어갈 수 있는것이다.
t1은 변수를 가져아서 증가해서 다시 변수로 가져다 가는데 
그런 여러가지 과정을 가지고 있다. 

문제는 그3개의 스텝 중간에 t2에게 쓰레드가 할당이 될 수 있기 때문에 문제가 발생한다. 
```



### 쓰레드의 동시 접근

문제가 생기는것이 우선 처음 t1이 

1. 변수 num을 가져온다.
2. num에 99 가 있는데 그걸 +1 해서 100으로 증가 시킨다.
3. 이때 원래 다시 변수를 제자리로 가져와야하는데 쓰레드가 t2로 할당이 된다.

그럼 t2의 동작이 실행

1. 변수 num을 가져온다.
2. num에 99가 있는데 아직 t1이 작업끝나고 안가져다놔서 99이다. -1 을 더한다.
3. 그리고 t2는 98이된 값을 변수num에 저장하고 다 끝내고 t1으로 쓰레드 할당

그러면 이때t1은  스텝 1부터 시작하느것이 아니고

3스텝부터 시작한다. 그럼 3스텝에는 100이 있기때문에 num 값이 100으로 바뀌게 된다.

그럼으로써 값이 달라지는것이다. 



**각 쓰레드 작업이 끝내고 넘기는것이 보장되어야한다.**



 공통자원에 동시에 접근했을때 문제가 생긴다. 



#### 해결책

작업이 끝날때 까지  다른 쓰레드가 접근하지 못하게 막거나

공통자원을 한쓰레드가 접근하고 있을때  들어오지 못하게 막는것 



이런것을 쓰레드의 동기화 라고 한다. 



## 동기화와 관련된 코드 

1. 동기화 관련

![image-20200617170256920](34-2%20%EC%93%B0%EB%A0%88%EB%93%9C%20%EB%8F%99%EA%B8%B0%ED%99%94.assets/image-20200617170256920.png)

특정 메소드 전체에  둘이상의 쓰레드를 막기위해 하는 선언 동기화 메소드 

 원래 동시에 실행되는 문장은 없다  하지만 문제가 되는것은 동일 변수 동일한 메모리에 

접근을 하기 때문에 문제가 되는것이다. 



위에의 구성 방식은 t1이 증가 메소드에 접근하고 있다면 t2는 감소 메소드라고 해도

t1의 증가 메소드가 끝날때 까지 기다려야 한다. 



즉, synchronized 되어있으면 다른 쓰레드가 각각의 메소드를 접근하더라도

한개의 쓰레드가 이미 동작을 하고있다면 다른 메소드라도 이전의 작업이 끝날때 까지

기다려야 한다.



여기서 증가 메소드에 41개의 문장이 있고

감소 메소드에 301개의 문장 이있는데 저렇게 한다고 햇을때  결과적으로 문제가 

생기지 않는데  저렇게 하면 301 개의 문장이 끝날 때 까지 기다려야한다는 

비합리적인 경우가 생기기 때문에 한개의 문자일 때만 대게 저렇게 쓰는걸 추천 한다. 



그래서 부분적으로 동기화하게 하는 방법이 아래 동기화 블록이다.



**동기화 블록 이란 **

![image-20200617170642124](34-2%20%EC%93%B0%EB%A0%88%EB%93%9C%20%EB%8F%99%EA%B8%B0%ED%99%94.assets/image-20200617170642124.png)

특정 블록을 둘이상의 쓰레드가 접근하는것을 막아주는 것



```
여기서 보이는 this는
synchronized(this){
	count++;
}
이 인스턴스 대상으로 동기화를 하겠다 인데 

여기서 보이는 this는 class Counter{
						}
자체 인스턴스를 말하는 것이다. 
```



이미지 출처 : 윤성우 열혈 java